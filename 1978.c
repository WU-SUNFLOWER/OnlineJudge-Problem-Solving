#include <stdio.h>

/*
金字塔的故乡埃及，也是数学的发源地之一。古埃及数系中，记数常采用分子为1的分数，称为“埃及分数”。
人们研究较多且颇感兴趣的问题是：把一个给定的分数转化为若干个不相同的埃及分数之和。
当然，转化的方法可能有很多种。常把分解式中埃及分数的个数最少，
或在个数相同时埃及分数中最大分母为最小的分解式称为最优分解式。
把给定整数或分数分解为埃及分数之和，分解的优化往往是一个烦琐艰辛的过程。
例如，对5/121，可分解为：5/121=1/61+1/62+1/121+1/3782+1/7381+1/7382+1/54486542，共有7个埃及分数组成；
还可以是5/121=1/25+1/759+1/208725, 由3个埃及分数构成，等等。

请构建指定真分数，并给定分解的埃及分数中分母上界的3个不同的埃及分数之和程序实现。

输入
输入两个正整数m,d (m<d, m/d就是指定的真分数)，以及一个分母上界。

输出
输出指定真分数的分解埃及分数式。若不存在，则输出"无分解式"。

样例输入
5,121,1100
样例输出
5/121=1/27+1/297+1/1089
5/121=1/33+1/99+1/1089
5/121=1/33+1/121+1/363
5/121=1/45+1/55+1/1089
*/

int main() {
	int son;
	int mum;
	int mumTop;
	int flag = 1;
	scanf("%d,%d,%d", &son, &mum, &mumTop);
	for (int i = 2; i <= mumTop; i++) {
		for (int j = i + 1; j <= mumTop; j++) {
			int x = mum * i * j;
			int y = son * i * j - mum * j - mum * i;
			if (y > 0 && x % y == 0) {
				int k = x / y;
				if (j < k && k <= mumTop) {
					flag = 0;
					printf("%d/%d=1/%d+1/%d+1/%d\n", son, mum, i, j, k);					
				}	
			}
		}
	}
	if (flag) {
		printf("无分解式\n");
	}
}