#include <stdio.h>

/*
在大学里，很多单词都是一词多义，偶尔在文章里还要用引申义。这困扰Redraiment很长的时间。
他开始搜集那些单词的所有意义。他发现了一些规律，例如
“a”能用“e”来代替, “c”能用“f”来代替……
现在他给出了字母的替换规则，如下所示，A被E替换，B被C替换，依次类推。
A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
E C F A J K L B D G H I V W Z Y M N O P Q R S T U X
a b c d e f g h i j k l m n o p q r s t u v w x y z
e r w q t y g h b n u i o p s j k d l f a z x c v m
*/

/*
本题包括多组测试数据。 每组测试数据为一行：为仅由字母和空格组成的字符串(空格不变)。 输入以单行“#”结束。

输入：
Ilttabaje zaujljg
#

输出：
对应每组测试数据，替换后输出它的引申义。
Different meaning
*/

int main() {
	char ch;
	char upperCaseArr[] = {'E', 'C', 'F', 'A', 'J', 'K', 'L', 'B', 'D', 'G', 'H', 'I', 'V', 'W', 'Z', 'Y', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'X'};
	char lowerCaseArr[] = {'e', 'r', 'w', 'q', 't', 'y', 'g', 'h', 'b', 'n', 'u', 'i', 'o', 'p', 's', 'j', 'k', 'd', 'l', 'f', 'a', 'z', 'x', 'c', 'v', 'm'};
	while((ch = getchar()) != '#') {
		if ('a' <= ch && ch <= 'z') {
			ch = lowerCaseArr[ch - 'a'];
		}
		else if ('A' <= ch && ch <= 'Z') {
			ch = upperCaseArr[ch - 'A'];
		}
		putchar(ch);
	}
	return 0;
}