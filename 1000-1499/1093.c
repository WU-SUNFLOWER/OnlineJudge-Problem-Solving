#include <stdio.h>
#include <math.h>

/*
老猴子辛苦了一辈子，给那群小猴子们留下了一笔巨大的财富——一大堆桃子。老猴子决定把这些桃子分给小猴子。
第一个猴子来了，它把桃子分成五堆，五堆一样多，但还多出一个。它把剩下的一个留给老猴子，自己拿走其中的一堆。
第二个猴子来了，它把桃子分成五堆，五堆一样多，但又多出一个。它把多出的一个留给老猴子，自己拿走其中的一堆。
后来的小猴子都如此照办。最后剩下的桃子全部留给老猴子。
这里有n只小猴子，请你写个程序计算一下在开始时至少有多少个桃子，以及最后老猴子最少能得到几个桃子。

输入:
输入包括多组测试数据。 每组测试数据包括一个整数n(1≤n≤20)。 输入以0结束，该行不做处理。

输出:
每组测试数据对应一行输出。 包括两个整数a，b。 分别代表开始时最小需要的桃子数，和结束后老猴子最少能得到的桃子数。
*/

/*
输入：
5
1
0
输出：
3121 1025
1 1
*/

/*
公式推导方法：
设数列t[n]表示第n只猴子来后，剩余的桃子总数；t[0]表示原先桃子总数
由题意列出递推式t[n] = t[n-1] - 1 - (t[n-1] - 1) / 5 = 4/5 * (t[n-1] - 1)
解出数列通项t[n] = (t[0] + 4) * (4/5)^n - 4
由于t[0]为整数，故t[0]的最小值满足t[0] + 4 = 5^n，解得t[0] = 5^n - 4
老猴子拿到的桃子总数为n（每个小猴子都给老猴子一个桃子） + t[0] - t[n]
*/

int main() {
	int n;
    while (1) {
        scanf("%d", &n);
        if (n == 0) {
        	break;
		}
		double totalPeaceNum = pow(5, n) - 4;
		double leftPeaceNum = n + pow(4/5.0, n) * (totalPeaceNum + 4) - 4;
		printf("%.0lf %.0lf\n", totalPeaceNum, leftPeaceNum);
    }
}