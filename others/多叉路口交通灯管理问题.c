#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

/* 
由排列组合的知识，五叉路口的通行情况最多有4+3*C(1,3)=13种。
即用于表达通行情况的抽象图中包含13个节点，图中节点共13*13种连通情况。
同时这也意味着至多设置13种颜色的信号灯可以解决问题。

本题可等价转换为图的涂色问题：
若要求图中的所有相邻节点之间颜色不同（在本题中即为互相冲突的通行情况，对应信号灯颜色不同），
问至少需要多少颜色，可以将图中所有节点涂色完。
*/
#define N 13

/* 
邻接矩阵存图
将所有代表互斥通行情况的节点进行连通
*/
int Graph[N][N] = {
				{0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,1,1,1,0,0,1,1,0},
				{0,0,0,0,0,1,0,0,0,1,1,1,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,1,1,0,0,1,1,1},
				{0,1,1,0,0,0,1,0,0,0,1,1,1},
				{0,1,0,0,1,1,0,0,0,0,1,1,1},
				{0,1,0,0,1,0,0,0,0,0,0,1,1},
				{0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,1,0,0,0,0,0,0,0,0,0,1},
				{0,1,1,0,1,1,1,0,0,0,0,0,1},
				{0,1,1,0,1,1,1,1,0,0,0,0,1},
				{0,0,0,0,1,1,1,1,0,1,1,1,0}
};

/* 该数组用于记录每个节点的涂色情况 */
int colorsRecord[N];

bool checkColor(int node, int color) {
    for (int i = 0; i < node; i++) {
        if (Graph[node][i] == 1 && colorsRecord[i] == color) {
            return false;
        }
    }
    return true;
}

bool dfs(int curNode, int totColor) {
    // 当所有节点都已涂色完毕，输出结果，结束程序
    if (curNode == N) {
        printf("至少需要%d种颜色的交通灯。具体设置情况如下：\n", totColor);
        for (int i = 0; i < N; i++) {
            printf("colors[%d]=%d\n", i, colorsRecord[i]);
        }
        return true;
    }
    // 尝试利用现有的颜色对节点进行上色
    for (int color = 1; color <= totColor; color++) {
        if (checkColor(curNode, color)) {
            colorsRecord[curNode] = color;
            if (dfs(curNode + 1, totColor)) {
                return true;
            }
        }
    }
    // 如果所有颜色经尝试都无法完成图的涂色，则结束程序
    return false;
}

int main() {
    /*
        这里有一种比较容易犯的错误：
        不可以在搜索的时候，一发现颜色不够用了就增加颜色。
        很容易想象到这样运用贪心解出来的结果不一定是最优解。
        正确的解法为：
        在搜索开始前就限制所需颜色总数，尔后考察该种情况下能否完成所有节点的涂色。
        由于已经知道了总颜色可能的范围，从范围左边界开始向右尝试所需颜色总数即可。
    */
    for (int tot = 1; tot <= N; tot++) {
        if (dfs(0, tot)) break;
    }
}